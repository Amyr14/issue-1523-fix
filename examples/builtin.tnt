module builtin {
  /// The infinite set of all natural numbers
  ///
  /// Some operators cannot be applied to inifine sets.
  pure val Nat: Set[int]

  /// The infinite set of all integers
  ///
  /// Some operators cannot be applied to inifine sets.
  pure val Int: Set[int]

  /// The set of all booleans
  /// That is, Set(false, true)
  pure val Bool: Set[bool]

  /// `a.eq(b)` is `true` when `a` and `b` are equal values of the same type.
  /// It can be used in the infix form as `==` or as a named operator `eq`.
  pure def eq(a, b): (t, t) => bool
  
  /// `a.neq(b)` is `true` when `a` and `b` are not equal values of the same type.
  /// It can be used in the infix form as `!=` or as a named operator `neq`.
  pure def neq(a, b): (t, t) => bool

  /// `p.iff(q)` is `true` when `p` and `q` are equal values of the bool type.
  ///
  /// This is the logical equivalence operator.
  ///
  /// # Examples
  ///
  /// ```
  /// assert(iff(true, true))
  /// assert(iff(false, false))
  /// assert(not(iff(true, false)))
  /// assert(not(iff(false, true)))
  /// ```
  pure def iff(p, q): (bool, bool) => bool

  /// `p.implies(q)` is true when `not(p) or q` is true.
  ///
  /// This is the material implication operator.
  /// 
  /// # Examples
  ///
  /// ```
  /// assert(true.implies(true))
  /// assert(false.implies(false))
  /// assert(not(true.implies(false)))
  /// assert(not(false.implies(true)))
  /// ```
  pure def implies(p, q): (bool, bool) => bool

  /// `not(p)` is `true` when `p` is `false`. 
  ///
  /// This is the negation opearator.
  pure def not(a): (bool) => bool

  /// Guess a value from the given set that satisfies the given predicate.
  /// This operator is non-deterministic.
  ///
  /// If the set is empty, then the result is `false`.
  ///
  /// # Examples
  /// ```
  /// var x: int
  /// run a = Set(1, 2, 3).guess(n => x' = n).then(assert(x.in(Set(1, 2, 3))))
  /// ```
  pure def guess(a, p): (Set[a], (a) => bool) => bool

  /// `s.exists(p)` is true when there is an element in `s` that satisfies `p`.
  /// Similar to `guess` but pure and deterministic.
  ///
  /// This is the existential quantifier.
  ///
  /// # Examples
  /// ```
  /// assert(Set(1, 2, 3).exists(n => n == 2))
  /// assert(not(Set(1, 2, 3).exists(n => n == 4)))
  /// ```
  pure def exists(a, p): (Set[a], (a) => bool) => bool
  
  /// `s.forall(p)` is true when all elements in `s` satisfy `p`.
  ///
  /// This is the universal quantifier.
  ///
  /// # Examples
  /// ```
  /// assert(Set(1, 2, 3).forall(n => n > 0))
  /// assert(not(Set(1, 2, 3).forall(n => n > 1)))
  /// ```
  pure def forall(a, p): (Set[a], (a) => bool) => bool

  /// `e.in(s)` is true when the element `e` is in the set `s`.
  ///
  /// This is the set membership relation.
  /// See also: `contains` 
  ///
  /// # Examples
  /// ```
  /// assert(1.in(Set(1, 2, 3)))
  /// assert(not(4.in(Set(1, 2, 3))))
  /// ```
  pure def in(a, s): (a, Set[a]) => bool

  /// `s.contains(e)` is true when the element `e` is in the set `s`.
  ///
  /// This is the set membership relation.
  /// See also: `in` 
  ///
  /// # Examples
  /// ```
  /// assert(Set(1, 2, 3).contains(1))
  /// assert(not(Set(1, 2, 3).contains(4)))
  /// ```
  pure def contains(a, s): (Set[a], a) => bool

  /// `e.notin(s)` is true when the element `e` is not in the set `s`.
  ///
  /// See also: `in`
  ///
  /// # Examples
  /// ```
  /// assert(4.notin(Set(1, 2, 3)))
  /// assert(not(1.notin(Set(1, 2, 3))))
  /// ```
  pure def notin(a, s): (a, Set[a]) => bool

  /// `s1.union(s2)` is the set of elements that are in `s1` or in `s2`.
  ///
  /// This is the set union operator.
  ///
  /// # Examples
  /// ```
  /// assert(Set(1, 2, 3).union(Set(2, 3, 4)) == Set(1, 2, 3, 4))
  /// ```
  pure def union(s1, s2): (Set[a], Set[a]) => Set[a]

  /// `s1.intersect(s2)` is the set of elements that are in both sets `s1` and `s2`.
  ///
  /// This is the set intersection operator.
  ///
  /// # Examples
  /// ```
  /// assert(Set(1, 2, 3).intersect(Set(2, 3, 4)) == Set(2, 3))
  /// ```
  pure def intersect(s1, s2): (Set[a], Set[a]) => Set[a]

  /// `s1.exclude(s2)` is the set of elements in `s1` that are not in `s2`.
  ///
  /// This is the set difference operator.
  ///
  /// # Examples
  /// ```
  /// assert(Set(1, 2, 3).exclude(Set(2, 3, 4)) == Set(1))
  /// ```
  pure def exclude(s1, s2): (Set[a], Set[a]) => Set[a]

  /// `s1.subseteq(s2)` is true when all elements in `s1` are also in `s2`. 
  ///
  /// # Examples
  /// ```
  /// assert(Set(1, 2, 3).subseteq(Set(1, 2, 3, 4)))
  /// assert(not(Set(1, 2, 3).subseteq(Set(1, 2))))
  /// ```
  pure def subseteq(s1, s2): (Set[a], Set[a]) => bool

  /// `s.filter(p)` is the set of elements in `s` that satisfy `p`. 
  ///
  /// # Examples
  /// ```
  /// assert(Set(1, 2, 3).filter(n => n > 1) == Set(2, 3))
  /// ```
  pure def filter(s, p): (Set[a], (a) => bool) => Set[a]

  /// `s.map(f)` is the set of elements obtained by applying `f` to  
  /// to each element in `s`. I.e., `{ f(x) : x \in s}`.
  ///
  /// # Examples
  /// ```
  /// assert(Set(1, 2, 3).map(n => n > 1) == Set(false, true, true))
  /// ```
  pure def map(s, f): (Set[a], (a) => b) => Set[b]

  /// `s.fold(z, f)` is the result of applying `f` to `z` and each element in `s`.
  /// I.e., `f(...f(f(z, x0), x1)..., xn)`.
  /// The order in which the elements are combined is unspecified, so
  /// the operator must be associative and commutative or else it has undefined behavior.
  ///
  /// # Examples
  /// ```
  /// val sum = Set(1, 2, 3, 4).fold(0, (x, y) => x + y)
  /// assert(sum == 10)
  /// val mul = Set(1, 2, 3, 4).fold(1, (x, y) => x * y)
  /// assert(mul == 24)
  /// ```
  pure def fold(s, v, f): (Set[a], b, (b, a) => b) => b

  /// `s.powerset()` is the set of all subsets of `s`,
  /// including the empty set and the set itself.
  ///
  /// # Examples
  /// ```
  /// assert(Set(1, 2).powerset() == Set(
  ///   Set(),
  ///   Set(1),
  ///   Set(2),
  ///   Set(1, 2)
  /// ))
  /// ```
  pure def powerset(s): Set[Set[a]] => Set[Set[a]]

  /// `s.flatten()` is the set of all elements in the sets in `s`.
  ///
  /// # Examples
  /// ```
  /// assert(Set(Set(1, 2), Set(3, 4)).flatten() == Set(1, 2, 3, 4))
  /// ```
  pure def flatten(s): Set[Set[a]] => Set[a]

  /// `s.allLists()` is the set of all lists containing all the elements in `s`.
  ///
  /// # Examples
  /// ```
  /// assert(Set(1, 2).allLists() == Set(
  ///   List(1, 2),
  ///   List(2, 1),
  /// )) 
  /// ```
  pure def allLists(s): Set[a] => Set[List[a]]

  /// `s.chooseSome()` is, deterministically, one element of `s`.
  /// 
  /// # Examples
  /// ```
  /// assert(Set(1, 2, 3).chooseSome() == 1)
  /// assert(Set(1, 2, 3).filter(x => x > 2).chooseSome() == 3)
  /// ```
  pure def chooseSome(s): Set[a] => a

  /// `s.oneOf()` is, non-deterministically, one element of `s`.
  ///
  /// # Examples
  /// ```
  /// assert(Set(1, 2, 3).oneOf().in(Set(1, 2, 3)))
  /// ```
  pure def oneOf(s): Set[a] => a

  /// `s.isFinite()` is true when `s` is a finite set
  ///
  /// # Examples
  /// ```
  /// assert(Set(1, 2, 3).isFinite())
  /// assert(!Nat.isFinite())
  /// ```
  pure def isFinite(s): Set[a] => bool

  /// `s.size()` is the cardinality of `s`.
  ///
  /// # Examples
  /// ```
  /// assert(Set(1, 2, 3).size() == 3)
  /// ```
  pure def size(s): Set[a] => int

  /// `m.get(k)` is the value for `k` in `m`.
  /// If `k` is not in `m` then the behavior is undefined.
  ///
  /// # Examples
  ///
  /// ```
  /// pure val m = Map(1 -> true, 2 -> false)
  /// assert(m.get(1) == true)
  /// ```
  pure def get(a, b): (a -> b, a) => b

  /// `m.keys()` is the set of keys in the map `m`.
  ///
  /// # Examples
  ///
  /// ```
  /// pure val m = Map(1 -> true, 2 -> false)
  /// assert(m.keys() == Set(1, 2))
  /// ```
  pure def keys(a): (a -> b) => Set[a]

  /// `s.mapBy(f)` is the map from `x` to `f(x)` for each element `x` in `s`.
  ///
  /// # Examples
  /// 
  /// ```
  /// pure val m = Set(1, 2, 3).mapBy(x => x * x)
  /// assert(m == Map(1 -> 1, 2 -> 4, 3 -> 9))
  /// ```
  pure def mapBy(s, f): (Set[a], (a) => b) => a -> b

  /// `s.setToMap()` for a set of pairs `s` is the map 
  /// from the first element of each pair to the second.
  ///
  /// # Examples
  ///
  /// ```
  /// pure val m = Set((1, true), (2, false)).setToMap()
  /// assert(m == Map(1 -> true, 2 -> false))
  /// ```
  pure def setToMap(s): (Set[(a, b)]) => (a -> b)
  
  /// Creates a set of all possible maps from a set of keys to a set of values.
  /// `keys.setOfMaps(values)` is the set of all maps from `keys` to `values`.
  ///
  /// # Examples
  ///
  /// ```
  /// pure val s = Set(1, 2).setOfMaps(set(true, false))
  /// assert(s == Set(
  ///   Map(1 -> true, 2 -> true),
  ///   Map(1 -> true, 2 -> false),
  ///   Map(1 -> false, 2 -> true),
  ///   Map(1 -> false, 2 -> false),
  /// ))
  /// ```
  pure def setOfMaps(s1, s2): (Set[a], Set[b]) => Set[a -> b]

  /// `m.set(k, v)` for `k.in(m.keys)` is a map with the same keys as `m` but with `k` set to `v`.
  /// If `k` is not present in `m`, this operator has undefined behavior.
  ///
  /// # Examples
  ///
  /// ```
  /// pure val m = Map(1 -> true, 2 -> false)
  /// pure val m2 = m.set(2, true)
  /// assert(m == Map(1 -> true, 2 -> false))
  /// assert(m2 == Map(1 -> true, 2 -> true))
  /// ```
  pure def set(m, k, v): (a -> b, a, b) => a -> b

  /// `m.setBy(k, f)` is a map with the same keys as `m` but with `k` set to `f(m.get(k))`.
  /// If `k` is not present in `m`, this operator has undefined behavior.
  ///
  /// # Examples
  ///
  /// ```
  /// pure val m = Map(1 -> true, 2 -> false)
  /// pure val m2 = m.setBy(2, x => !x)
  /// assert(m == Map(1 -> true, 2 -> false))
  /// assert(m2 == Map(1 -> true, 2 -> true))
  /// ```
  pure def setBy(m, k, v): (a -> b, a, (b) => b) => a -> b

  /// `m.put(k, v)` for `k.notin(m.keys)` is a map with the same keys as `m` but with `k` set to `v`.
  /// If `k` is present in `m`, this operator has undefined behavior.
  ///
  /// # Examples
  ///
  /// ```
  /// pure val m = Map(1 -> true, 2 -> false)
  /// pure val m2 = m.put(3, true)
  /// assert(m == Map(1 -> true, 2 -> false))
  /// assert(m2 == Map(1 -> true, 2 -> false, 3 -> true))
  /// ```
  pure def put(m, k, v): (a -> b, a, b) => a -> b

  /// `l.append(e)` is the list `l` with `e` appended.
  ///
  /// # Examples
  ///
  /// ```
  /// assert(List(1, 2, 3).append(4) == List(1, 2, 3, 4))
  /// ```
  pure def append(l, e): (List[a], a) => List[a]
  
  /// `l1.concat(l2)` is the list `l1` with `l2` concatenated at the end.
  ///
  /// # Examples
  /// 
  /// ```
  /// assert(List(1, 2, 3).append(List(4, 5, 6)) == List(1, 2, 3, 4, 5, 6))
  /// ```
  pure def concat(l1, l2): (List[a], List[a]) => List[a]

  /// `l.head()` is the first element of `l`.
  /// If `l` is empty, the behavior is undefined.
  /// 
  /// # Examples
  ///
  /// ```
  /// assert(List(1, 2, 3).head() == 1)
  /// ```
  pure def head(l): (List[a]) => a

  /// `l.tail()` is the list `l` without the first element.
  /// If `l` is empty, the behavior is undefined.
  ///
  /// # Examples
  ///
  /// ```
  /// assert(List(1, 2, 3).tail() == List(2, 3))
  /// ```
  pure def tail(l): (List[a]) => List[a]

  /// `l.length()` is the length of the list `l`.
  ///
  /// # Examples
  ///
  /// ```
  /// assert(List(1, 2, 3).length() == 3)
  /// ```
  pure def length(l): (List[a]) => int

  /// `l.nth(i)` is the `i+1`th element of the list `l`.
  /// If `i` is negative or greater than or equal to `l.length()`, the behavior is undefined.
  ///
  /// # Examples
  ///
  /// ```
  /// assert(List(1, 2, 3).nth(1) == 2)
  /// ```
  pure def nth(l, i): (List[a], int) => a

  /// `l.indices()` is the set of indices of `l`.
  ///
  /// # Examples
  ///
  /// ```
  /// assert(List(1, 2, 3).indices() == Set(0, 1, 2))
  /// ```
  pure def indices(l): (List[a]) => Set[int]

  /// `l.replaceAt(i, e)` is the list `l` with the `i+1`th element replaced by `e`.
  /// If `i` is negative or greater than or equal to `l.length()`, the behavior is undefined.
  ///
  /// # Examples
  ///
  /// ```
  /// assert(List(1, 2, 3).replaceAt(1, 4) == List(1, 4, 3))
  /// ```
  pure def replaceAt(l, i, e): (List[a], int, a) => List[a]

  /// `l.slice(i, j)` is the list of elements of `l` between indices `i` and `j`.
  /// `i` is inclusive and `j` is exclusive.
  ///
  /// The behavior is undefined when:
  /// - `i` is negative or greater than or equal to `l.length()`.
  /// - `j` is negative or greater than `l.length()`.
  /// - `i` is greater than `j`.
  ///
  /// # Examples
  ///
  /// ```
  /// assert(List(1, 2, 3, 4, 5).slice(1, 3) == List(2, 3))
  /// ```
  pure def slice(l, i, j): (List[a], int, int) => List[a]

  /// `range(i, j)` is the list of integers between `i` and `j`.
  /// `i` is inclusive and `j` is exclusive.
  ///
  /// The behavior is undefined when `i` is greater than `j`.
  ///
  /// # Examples
  ///
  /// ```
  /// assert(range(1, 3) == List(1, 2))
  /// ```
  pure def range(i, j): (int, int) => List[int]

  /// `l.select(p)` is the list of elements of `l` that satisfy the predicate `p`.
  ///
  /// Preserves the order of the elements.
  /// 
  /// # Examples
  ///
  /// ```
  /// assert(List(1, 2, 3).select(x -> x % 2 == 0) == List(2))
  /// ```
  pure def select(l, p): (List[a], (a) => bool) => List[a]

  /// `l.foldl(z, f)` is the result of applying `f` to `z` and each element in `s`.
  /// I.e., `f(f(f(z, x0), x1)..., xn)`.
  ///
  /// # Examples
  /// ```
  /// pure val sum = List(1, 2, 3, 4).foldl(0, (x, y) => x + y)
  /// assert(sum == 10)
  /// pure val l = List(1, 2, 3, 4).foldl(List(), (l, e) => l.append(e))
  /// assert(l == List(1, 2, 3, 4))
  /// ```
  pure def foldl(l, z, f): (List[a], b, (b, a) => b) => b
  
  /// `l.foldr(z, f)` is the result of applying `f` to each element in `s` and `z`.
  /// I.e., `f(x0, f(x1, ... f(xn, z))`.
  ///
  /// # Examples
  /// ```
  /// pure val sum = List(1, 2, 3, 4).foldr(0, (x, y) => x + y)
  /// assert(sum == 10)
  /// pure val l = List(1, 2, 3, 4).foldr(List(), (e, l) => l.append(e))
  /// assert(l == List(4, 3, 2, 1))
  /// ```
  pure def foldr(l, z, f): (List[a], b, (a, b) => b) => b

  /// `a.iadd(b)` is the integer addition of `a` and `b`.
  /// It can be used in the infix form as `+` or as a named operator `iadd`.
  pure def iadd(a, b): (int, int) => int
  
  /// `a.isub(b)` is the integer subtraction of `a` and `b`.
  /// It can be used in the infix form as `-` or as a named operator `isub`.
  pure def isub(a, b): (int, int) => int

  /// `a.imul(b)` is the integer multiplication of `a` and `b`.
  /// It can be used in the infix form as `*` or as a named operator `imul`.
  pure def imul(a, b): (int, int) => int

  /// `a.idiv(b)` is the integer division of `a` and `b`.
  /// It can be used in the infix form as `/` or as a named operator `idiv`.
  pure def idiv(a, b): (int, int) => int

  /// `a.imod(b)` is the integer modulus of `a` and `b`.
  /// It can be used in the infix form as `%` or as a named operator `imod`.
  pure def imod(a, b): (int, int) => int

  /// `a.ipow(b)` is the integer exponentiation of `a` and `b`.
  /// It can be used in the infix form as `^` or as a named operator `ipow`.
  pure def ipow(a, b): (int, int) => int

  /// `a.ilt(b)` is the integer less than comparison of `a` and `b`.
  /// It can be used in the infix form as `<` or as a named operator `ilt`.
  pure def ilt(a, b): (int, int) => bool

  /// `a.igt(b)` is the integer greater than comparison of `a` and `b`.
  /// It can be used in the infix form as `>` or as a named operator `igt`.
  pure def igt(a, b): (int, int) => bool

  /// `a.ilte(b)` is the integer less than or equal to comparison of `a` and `b`.
  /// It can be used in the infix form as `<=` or as a named operator `ilte`.
  pure def ilte(a, b): (int, int) => bool

  /// `a.igte(b)` is the integer greater than or equal to comparison of `a` and `b`.
  /// It can be used in the infix form as `>=` or as a named operator `igte`.
  pure def igte(a, b): (int, int) => bool

  /// `iuminus(a)` is `-1 * a`.
  ///
  /// This is the unary minus operator
  pure def iuminus(a): (int) => int

  /// `i.to(j)` is the set of integers between `i` and `j`.
  /// `i` is inclusive and `j` is exclusive.
  ///
  /// The behavior is undefined when `i` is greater than `j`.
  ///
  /// # Examples
  ///
  /// ```
  /// assert(1.to(3) == Set(1, 2))
  /// ```
  pure def to(i, j): (int, int) => Set[int]

  /// `always(p)` is true when `p` is true for every transition of the system.
  ///
  /// # Examples
  ///
  /// ```
  /// var x: int
  /// action Init = x' = 0
  /// action Next = x' = x + 1
  /// action Inv = always(next(x) > x) 
  /// ```
  temporal always(p): (bool) => bool
  temporal eventually(a): (bool) => bool
  temporal next(a): (a) => a
  temporal stutter(a, b): (bool, a) => bool
  temporal nostutter(a, b): (bool, a) => bool
  temporal enabled(a): (bool) => bool
  temporal weakFair(a, b): (bool, a) => bool
  temporal strongFair(a, b): (bool, a) => bool

  action assign(n, v): (a, a) => bool
  action ite(c, t, e): (bool, a, a) => a
  action then(a, t): (bool, bool) => bool
  action repeated(a, n): (bool, int) => bool
  pure assert(a): (bool) => bool

  pure def List(a*): (a*) => List[a]
  pure def Set(a*): (a*) => Set[a]
  pure def Map((a -> b)*): ((a, b)* => a -> b
  pure def and(a*): (bool*) => bool
  pure def actionAll(a*): (bool*) => bool
  pure def or(a*): (bool*) => bool
  pure def actionAny(a*): (bool*) => bool
  pure def match(m, (v, f)): (a, (b, (b => c))*) => c*
  pure def tuples(a*): (Set[a0], ..., Set[an]) => Set[(a0, ..., an)]
}

// a module that contains constants
module withConsts {
    // Constants
	const N: int
	const MySet: set(int)
	const MySeq: seq(bool)
	const MyFun: int -> str
	const MyFunFun: (int -> str) -> bool
	const MyOper: (int, str) => bool
	const MyTuple: (int, bool, str)

	// just a normal record, without any variation in the fields
	const MyRecord: { i: int, b: bool, s: str }
	// a disjoint union is a common pattern in TLA+
	const MyUnion:
		| { tag: "circle", radius: int }
		| { tag: "rectangle", width: int, height: int }
		| { tag: "dog", name: str }

    // Vars
    // We don't do extensive testing of types,
    // as we have done it for constants already.
	var x: int
	var y: bool

    // Vals
    // Since 'val' gives us the simplest way of defining expressions,
    // we also do extensive testing of expression syntax in this test.
	val add_1_to_2 = 1 + 2
	val sub_1_to_2 = 1 - 2
	val mul_2_to_3 = 2 * 3
	val div_2_to_3 = 2 / 3
	val mod_2_to_3 = 2 % 3
	val pow_2_to_3 = 2^3
	val uminus = -100
	val gt_2_to_3 = 2 > 3
	val ge_2_to_3 = 2 >= 3
	val lt_2_to_3 = 2 < 3
	val le_2_to_3 = 2 <= 3
	val eqeq_2_to_3 = 2 == 3
	val ne_2_to_3 = 2 != 3
	val VeryTrue = {
		2 + 2 == 4
	}

    // Typed vals
	val withType: set(int) = set(1, 2)
	// PROC is an uninterpreted type
	val withUninterpretedType: set(PROC) = set()

    // Operator definitions
    var n: int
	def G(x, y) = x + y
	pred P(x, y) = x > y
	action A(x) = n <- x
	temporal F(x) = not(x)

    // Typed operators
	def H(x, y): (int, int) => int = {
		x + y
	}
    // P has a parametric type
	def P(x): (a) => a = {
		x
	}

    var x: int
	action asgn = x <- 3


    // Logical operators
	val test_and = false and true
	val test_or = false or true
	val test_implies = false implies true
    def F(x) = x
    val G(x) = F(x) and not(x)
    val test_and(x) = F(x) and not(x)
    val test_or(x) = F(x) or not(x)

    val test_block_and = (
		& false
		& true
		& false
	)

    action test_action_and = {
		& false
		& true
		& false
	}

    val test_block_or = (
		| false
		| true
		| false
	)

    action test_action_or = {
		| false
		| true
		| false
	}

    val test_ite = if (true) 1 else 0

    // Function application
    var f: str -> int
	val funapp = f["a"]

    // Apply a user-defined operator by its name.
	def MyOper(a, b) = 1
	val oper_app = MyOper("a", 42)
	val oper_app = "a" MyOper 42, true
    // the following operators need a special parsing case
	val oper_in = in(1, set())

    // Infix application with lambdas
    val S = set(1)
	// Pass a lambda operator as a second argument of filter.
	// Here we are using the infix notation.
	val oper_app = S filter (x -> x > 10)
    // We can omit parentheses, though this form is harder to read.
	val oper_app2 = S filter x -> x > 10
    // Some operators accept action lambdas
	action oper_app3 = S guess { x -> x > 10 }
    // use holes
	val oper_app = S filter (_, _ -> true)

    // Dot notation application with lambdas
    val S = set(1)
	// Pass a lambda operator as a second argument of filter.
	// Here we are using the dot notation.
	val oper_app = S.filter(x -> x > 10)
    // Wrap lambda in '(...)'
	val oper_app2 = S.filter((x -> x > 10))
    // Wrap lambda in '{...}'
	action oper_app3 = S.guess({x -> x > 10})
    // use holes
	val oper_app = S.filter(_, _ -> true)

    val S = set(1, 2, 3, 4)
	val f = S.mapOf(x -> x + 1)
	// Pass non-lambda arguments.
	// Here we are using the dot notation.
	val oper_app = f.exclude(3, 4)

    // call the operator of one argument
	val one = f.head()

    // Data structures
    val test_tuple = (1, 2, 3)
	val test_tuple2 = tup(1, 2, 3)
	val test_seq = [1, 2, 3]
	val test_seq2 = seq(1, 2, 3)
	val test_record = { name: "igor", year: 1981 }
	val test_record2 = rec("name", "igor", "year", 1981)
	val test_set = set(1, 2, 3)

    // access a record via dot
    val rec_field =
      val rec = { a: 1, b: "foo" }
      rec.a

    val tup_elem =
      val tup = tup("a", 3)
      tup._2

    def isEmpty(s) = s == []

    // Infix operators
    val in_2_empty = 2 in set()
	val notin_2_empty = 2 notin set()
	val subseteq_empty = set() subseteq set()

    // Nested Modules
    module level2 {
      var y: int

      module level3 {
        var z: int
      }
    }

  // Assumes
  const N: int
  // a named assumption
  assume positive = N > 0
  // an anonymous assumption
  assume _ = N != 0

  // Imports
  module M {
    val foo = 4
  }

  import M.foo
  import M.*

  // Typedefs
  type INT_SET = set(int)

  var S: INT_SET

  // Instances
  module Proto {
    const N: int
    var x: int
  }

  // create an instance of Proto by associating constants and variables
  module Inst1 = Proto(N = N, x = x)
  // create an instance of Proto by using '*'
  module Inst2 = Proto(*)

  // Match
  type ENTRY_TYPE =
      | { tag: "Cat", name: str, year: int }
      | { tag: "Date", day: int, month: int, year: int }

  pred isValid(entry) =
    entry match
       | "Cat": cat -> cat.name != ""
       | "Date": date -> date.year > 0

}

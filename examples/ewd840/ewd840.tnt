module EWD840

/***************************************************************************)
(* TLA+ specification of an algorithm for distributed termination          *)
(* detection on a ring, due to Dijkstra, published as EWD 840:             *)
(* Derivation of a termination detection algorithm for distributed         *)
(* computations (with W.H.J.Feijen and A.J.M. van Gasteren).               *)
(***************************************************************************/

const N: _
assume NAssumption = N in (Nat minus '{0})

typedef NODE = int

var active: NODE -> bool
var color: NODE -> str
var tpos: NODE
var tcolor: str

val Node = 0 to N - 1
val Color = '{ "white", "black" }

pred TypeOK = {
  & active in (Node mkFunSet Bool)      // status of nodes (active or passive)
  & color in (Node mkFunSet Color)      // color of nodes
  & tpos in Node                        // token position
  & tcolor in Color                     // token color
}

/***************************************************************************)
(* Initially the token is black. The other variables may take any          *)
(* "type-correct" values.                                                  *)
(***************************************************************************/
action Init = {
  & (Node mkFunSet Bool) guess  { a -> active := f }
  & (Node mkFunSet Color) guess { c -> color := f }
  & Node guess { n -> tpos := n }
  & tcolor := "black"
}

/***************************************************************************)
(* Node 0 may initiate a probe when it has the token and when either it is *)
(* black or the token is black. It passes a white token to node N-1 and    *)
(* paints itself white.                                                    *)
(***************************************************************************/
action InitiateProbe = {
  & tpos = 0
  & tcolor = "black" or color[0] = "black"
  & tpos := N - 1
  & tcolor := "white"
  & active := active
  & color := color.except(0, "white")
}

/***************************************************************************)
(* A node i different from 0 that possesses the token may pass it to node  *)
(* i-1 under the following circumstances:                                  *)
(*   - node i is inactive or                                               *)
(*   - node i is colored black or                                          *)
(*   - the token is black.                                                 *)
(* Note that the last two conditions will result in an inconclusive round, *)
(* since the token will be black. The token will be stained if node i is   *)
(* black, otherwise its color is unchanged. Node i will be made white.     *)
(***************************************************************************/
action PassToken(i) = {
  & tpos = i
  & not(active[i]) or color[i] = "black" or tcolor = "black"
  & tpos := i - 1
  & tcolor := if (color[i] = "black") "black" else tcolor
  & active := active
  & color := color.except(i, "white")
}

/***************************************************************************)
(* token passing actions controlled by the termination detection algorithm *)
(***************************************************************************/
action System = {
  | InitiateProbe
  | (Node minus '{0}) guess { i -> PassToken(i) }
}

/***************************************************************************)
(* An active node i may activate another node j by sending it a message.   *)
(* If j>i (hence activation goes against the direction of the token being  *)
(* passed), then node i becomes black.                                     *)
(***************************************************************************/
action SendMsg(i) = {
  & active[i]
  & (Node minus {i}) guess { j -> {
        & active  := active.except(j, TRUE)
        & color   := color exceptAt i, { old -> if (j > i) "black" else old }
      }
    }
  & unchanged((tpos, tcolor))
}

/***************************************************************************)
(* Any active node may become inactive at any moment.                      *)
(***************************************************************************/
action Deactivate(i) = {
  & active[i]
  & active := active.except(i, false)
  & unchanged((color, tpos, tcolor))
}

/***************************************************************************)
(* actions performed by the underlying algorithm                           *)
(***************************************************************************/
action Environment =
  Node guess { i -> { SendMsg(i) | Deactivate(i) } }

/***************************************************************************)
(* next-state relation: disjunction of above actions                       *)
(***************************************************************************/
action Next = { System | Environment }

val vars = (active, color, tpos, tcolor)

temporal Spec = Init and always(Next.stutter(vars) and System.weakFair(vars))

//-----------------------------------------------------------------------------

/***************************************************************************)
(* Non-properties, useful for validating the specification with TLC.       *)
(***************************************************************************/
pred TokenAlwaysBlack = tcolor = "black"

temporal NeverChangeColor = always(unchanged(color).stutter(vars))

/***************************************************************************)
(* Main safety property: if there is a white token at node 0 then every    *)
(* node is inactive.                                                       *)
(***************************************************************************/
pred terminationDetected = {
  & tpos = 0 and tcolor = "white"
  & color[0] = "white" and not(active[0])
}  

pred TerminationDetection =
  terminationDetected implies Node.forall(i -> not active[i])

/***************************************************************************)
(* Liveness property: termination is eventually detected.                  *)
(***************************************************************************/
temporal Liveness =
  always(Node.forall(i -> not(active[i])) implies eventually(terminationDetected))

/***************************************************************************)
(* The following property asserts that when every process always           *)
(* eventually terminates then eventually termination will be detected.     *)
(* It does not hold since processes can wake up each other.                *)
(***************************************************************************/
temporal FalseLiveness =
  always(Node.forall(i -> always(eventually(not(active[i]))))
         implies eventually(terminationDetected))

/***************************************************************************)
(* The following property says that eventually all nodes will terminate    *)
(* assuming that from some point onwards no messages are sent. It is       *)
(* not supposed to hold: any node may indefinitely perform local           *)
(* computations. However, this property is verified if the fairness        *)
(* condition WF_vars(Next) is used instead of only WF_vars(System) that    *)
(* requires fairness of the actions controlled by termination detection.   *)
(***************************************************************************/
temporal SpecWFNext = Init and always(Next.stutter(vars) and Next.weakfair(vars))

temporal AllNodesTerminateIfNoMessages = {
  eventually(always(
      Node.forall(i -> not(SendMsg(i))).stutter(vars)
  )) implies eventually(Node.forall(i -> not(active[i])))
}

/***************************************************************************)
(* Dijkstra's inductive invariant                                          *)
(***************************************************************************/
pred Inv = {
  | Node.forall(i -> tpos < i implies not(active[i]))
  | (0 to tpos).exists(j -> color[j] = "black")
  | tcolor = "black"
}

/***************************************************************************)
(* Use the following specification to let TLC check that the predicate     *)
(* TypeOK /\ Inv is inductive for EWD 840: verify that it is an            *)
(* (ordinary) invariant of a specification obtained by replacing the       *)
(* initial condition by that conjunction.                                  *)
(***************************************************************************/
temporal CheckInductiveSpec = TypeOK and Inv and always(Next.stutter(vars))

/***************************************************************************)
(* The algorithm implements the high-level specification of termination    *)
(* detection in a ring with synchronous communication between nodes.       *)
(* Note that the parameters of the module SyncTerminationDetection are     *)
(* instantiated by the symbols of the same name in the present module.     *)
(***************************************************************************/
instance TD = SyncTerminationDetection

//THEOREM Spec => TD!Spec

end

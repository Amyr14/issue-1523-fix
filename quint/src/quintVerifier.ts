/* ----------------------------------------------------------------------------------
 * Copyright (c) Informal Systems 2023. All rights reserved.
 * Licensed under the Apache 2.0.
 * See License.txt in the project root for license information.
 * --------------------------------------------------------------------------------- */

/**
 * Interface to Apalache's model checking functionality
 *
 * This functionality is exposed thru the Apalache server.
 *
 * @author Shon Feder
 *
 * @module
 */

import { Either, left, right } from '@sweet-monads/either'
import { ErrorMessage } from './parsing/quintParserFrontend'
import { spawnSync } from 'child_process'
import path from 'path'
import fs from 'fs'
import os from 'os'
import * as grpc from '@grpc/grpc-js'
import * as proto from '@grpc/proto-loader'
import * as protobufDescriptor from 'protobufjs/ext/descriptor'
import { setTimeout } from 'timers/promises'
import { promisify } from 'util'
import { ItfTrace } from './itf'

import type { Buffer } from 'buffer'
import type { PackageDefinition as ProtoPackageDefinition } from '@grpc/proto-loader'

const APALACHE_SERVER_URI = 'localhost:8822'
// These will be addressed as we work out the packaging for apalche
// See https://github.com/informalsystems/quint/issues/701
// TODO const APALACHE_VERSION = "0.30.8"
// TODO const DEFAULT_HOME = path.join(__dirname, 'apalache')

// The structure used to report errors
type VerifyError = {
  explanation: string
  errors: ErrorMessage[]
  traces?: ItfTrace[]
}

export type VerifyResult<T> = Either<VerifyError, T>

// Paths to the apalache distribution
type ApalacheDist = { jar: string; exe: string }

// An object representing the Apalache configuration
// See https://github.com/informalsystems/apalache/blob/main/mod-infra/src/main/scala/at/forsyte/apalache/infra/passes/options.scala#L255
type ApalacheConfig = any

// Interface to the apalache server
// This is likely to be expanded in the future
type Apalache = {
  // Run the check command with the given configuration
  check: (c: ApalacheConfig) => Promise<VerifyResult<void>>
}

function handleVerificationFailure(failure: { pass_name: string; error_data: any }): VerifyError {
  switch (failure.pass_name) {
    case 'SanyParser':
      return {
        explanation: `internal error: while parsing in Apalache:\n'${failure.error_data}'\nPlease report an issue: https://github.com/informalsystems/quint/issues/new`,
        errors: [],
      }
    case 'TypeCheckerSnowcat':
      return {
        explanation: `internal error: while type checking in Apalache:\n'${failure.error_data}'\nPlease report an issue: https://github.com/informalsystems/quint/issues/new`,
        errors: [],
      }
    case 'BoundedChecker':
      switch (failure.error_data.checking_result) {
        case 'Error':
          return { explanation: 'found a counterexample', traces: failure.error_data.counterexamples, errors: [] }
        case 'Deadlock':
          return { explanation: 'reached a deadlock', traces: failure.error_data.counterexamples, errors: [] }
        default:
          throw new Error(`internal error: unhandled verification error ${failure.error_data.checking_result}`)
      }
    default:
      throw new Error(`internal error: unhandled verification error at pass ${failure.pass_name}`)
  }
}

// Construct the Apalache interface around the cmdExecutor
function apalache(cmdExecutor: AsyncCmdExecutor): Apalache {
  const check = async (c: ApalacheConfig): Promise<VerifyResult<void>> => {
    const response = await cmdExecutor.run({ cmd: 'CHECK', config: JSON.stringify(c) })
    if (response.result == 'success') {
      return right(void 0)
    } else {
      switch (response.failure.errorType) {
        case 'UNEXPECTED': {
          const errData = JSON.parse(response.failure.data)
          return err(errData.msg)
        }
        case 'PASS_FAILURE':
          return left(handleVerificationFailure(JSON.parse(response.failure.data)))
        default:
          // TODO handle other error cases
          return err(`${response.failure.errorType}: ${response.failure.data}`)
      }
    }
  }

  return { check }
}

// Alias for an async callback for values of type T used to annotate
// callback-based methods so we can convert them into promise-based methods via
// promiseify.
type AsyncCallBack<T> = (err: any, result: T) => void

// The core grpc tooling doesn't support generation of typing info,
// we therefore record the structer we require from the grpc generation
// in the 6 following types.
//
// The types reflect https://github.com/informalsystems/apalache/blob/main/shai/src/main/protobuf/cmdExecutor.proto

type RunRequest = { cmd: string; config: string }

type RunResponse =
  | { result: 'failure'; failure: { errorType: string; data: string } }
  // The success data also includes the parsed module, but we don't need it
  | { result: 'success' }

// The interface for the CmdExecutor service generated by the gRPC library
type CmdExecutor = {
  // Constructs a new client service
  new (url: string, creds: any): CmdExecutor
  run: (req: RunRequest, cb: AsyncCallBack<any>) => void
  ping: (o: {}, cb: AsyncCallBack<void>) => void
}

// The refined interface to the CmdExecutor we produce from the generated interface
type AsyncCmdExecutor = {
  run: (req: RunRequest) => Promise<RunResponse>
  ping: () => Promise<void>
}

// The interface for the Shai package
type ShaiPkg = {
  cmdExecutor: {
    CmdExecutor: CmdExecutor
  }
}

// Helper to construct errors results
function err<A>(explanation: string, errors: ErrorMessage[] = [], traces?: ItfTrace[]): VerifyResult<A> {
  return left({ explanation, errors, traces })
}

function findApalacheDistribution(): VerifyResult<ApalacheDist> {
  const dist = path.isAbsolute(process.env.APALACHE_DIST!)
    ? process.env.APALACHE_DIST!
    : path.join(process.cwd(), process.env.APALACHE_DIST!)

  if (!fs.existsSync(dist)) {
    return err(`Specified APALACHE_DIST ${dist} does not exist.`)
  }

  const jar = path.join(dist, 'lib', 'apalache.jar')
  const exe = path.join(dist, 'bin', 'apalache-mc')

  if (!fs.existsSync(jar)) {
    return err(
      `Apalache distribution is corrupted: cannot find ${jar}. Ensure the APALACHE_DIST environment variable points to the right directory.`
    )
  }
  if (!fs.existsSync(exe)) {
    return err(
      `Apalache distribution is corrupted: cannot find ${exe}. Ensure the APALACHE_DIST environment variable points to the right directory.`
    )
  }

  return right({ jar, exe })
}

// See https://grpc.io/docs/languages/node/basics/#example-code-and-setup
const grpcStubOptions = {
  keepCase: true,
  longs: String,
  enums: String,
  defaults: true,
  oneofs: true,
}

function loadProtoDefViaDistribution(dist: ApalacheDist): VerifyResult<ProtoPackageDefinition> {
  const jarUtilitiyIsInstalled = spawnSync('jar', ['--version']).status === 0
  if (!jarUtilitiyIsInstalled) {
    return err('The `jar` utility must be installed')
  }

  // The proto file we extract from the apalache jar
  const protoFileName = 'cmdExecutor.proto'
  // Used as the target for the extracted proto file
  const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'apalache-proto-'))
  const protoFile = path.join(tmpDir, protoFileName)

  const protoIsFileExtracted = spawnSync('jar', ['xf', dist.jar, protoFileName], { cwd: tmpDir }).status === 0
  if (!protoIsFileExtracted) {
    return err(`Apalache distribution is corrupted. Could not extract proto file from apalache.jar.`)
  }

  const protoDef = proto.loadSync(protoFile, grpcStubOptions)
  // We have the proto file loaded, so we can delete the tmp dir
  fs.rmSync(tmpDir, { recursive: true, force: true })

  return right(protoDef)
}

async function loadProtoDefViaReflection(): Promise<VerifyResult<ProtoPackageDefinition>> {
  type ServerReflectionRequest = { file_containing_symbol: string }
  type ServerReflectionResponseSuccess = {
    file_descriptor_response: {
      file_descriptor_proto: Buffer[]
    }
  }
  type ServerReflectionResponseFailure = {
    error_response: {
      error_code: number
      error_message: string
    }
  }
  type ServerReflectionResponse = ServerReflectionResponseSuccess | ServerReflectionResponseFailure
  type ServerReflectionService = {
    new (url: string, creds: grpc.ChannelCredentials): ServerReflectionService
    ServerReflectionInfo: () => grpc.ClientDuplexStream<ServerReflectionRequest, ServerReflectionResponse>
  }
  type ServerReflectionPkg = {
    grpc: { reflection: { v1alpha: { ServerReflection: ServerReflectionService } } }
  }

  // Obtain a reflection service client
  // To load from HTTP:
  // const protoJson = protobuf.parse(response.data, grpcStubOptions).root.toJSON()
  // const packageDefinition = proto.fromJSON(protoJson, grpcStubOptions)
  const protoPath = require.resolve('./reflection.proto')
  const packageDefinition = proto.loadSync(protoPath, grpcStubOptions)
  const reflectionProtoDescriptor = grpc.loadPackageDefinition(packageDefinition) as unknown as ServerReflectionPkg
  const serverReflectionService = reflectionProtoDescriptor.grpc.reflection.v1alpha.ServerReflection
  const reflectionClient = new serverReflectionService(APALACHE_SERVER_URI, grpc.credentials.createInsecure())

  // Query reflection endpoint
  const response: VerifyResult<ServerReflectionResponse> = await new Promise<ServerReflectionResponse>(
    (resolve, reject) => {
      const call = reflectionClient.ServerReflectionInfo()
      call.on('data', (r: ServerReflectionResponse) => {
        call.end()
        resolve(r)
      })
      call.on('error', (e: grpc.StatusObject) => reject(e))

      call.write({ file_containing_symbol: 'shai.cmdExecutor.CmdExecutor' })
    }
  )
    .then(right)
    .catch(e => err(`Apalache gRPC endpoint is corrupted. Error reading from streaming API: ${e.details}`))

  return response.chain((protoDefResponse: ServerReflectionResponse) => {
    if ('error_response' in protoDefResponse) {
      return err(
        `Apalache gRPC endpoint is corrupted. Could not extract proto file: ${protoDefResponse.error_response.error_message}`
      )
    }

    // Decode reflection response to FileDescriptorProto
    let fileDescriptorProtos = protoDefResponse.file_descriptor_response.file_descriptor_proto.map(
      bytes => protobufDescriptor.FileDescriptorProto.decode(bytes) as protobufDescriptor.IFileDescriptorProto
    )

    // Use proto-loader to load the FileDescriptorProto wrapped in a FileDescriptorSet
    return right(proto.loadFileDescriptorSetFromObject({ file: fileDescriptorProtos }, grpcStubOptions))
  })
}

function loadGrpcClient(protoDef: ProtoPackageDefinition): VerifyResult<AsyncCmdExecutor> {
  const protoDescriptor = grpc.loadPackageDefinition(protoDef)
  // The cast thru `unkown` lets us convince the type system of anything
  // See https://basarat.gitbook.io/typescript/type-system/type-assertion#double-assertion
  const pkg = protoDescriptor.shai as unknown as ShaiPkg
  const stub = new pkg.cmdExecutor.CmdExecutor(APALACHE_SERVER_URI, grpc.credentials.createInsecure())
  const impl: AsyncCmdExecutor = {
    run: promisify((data: RunRequest, cb: AsyncCallBack<any>) => stub.run(data, cb)),
    ping: promisify((cb: AsyncCallBack<void>) => stub.ping({}, cb)),
  }
  return right(impl)
}

// Retry a function repeatedly, in .5 second intervals, until it does not throw.
async function retry<T>(f: () => Promise<T>): Promise<T> {
  for (;;) {
    // avoid linter error on while(true): https://github.com/eslint/eslint/issues/5477
    try {
      return await f()
    } catch {
      // Wait .5 secs before retry
      await setTimeout(500)
    }
  }
}

// Call `f` repeatedly until its promise resolves, in .5 second intervals, for up to 5 seconds.
// Returns right(T) on success, or a left(VerifyError) on timeout.
async function retryWithTimeout<T>(f: () => Promise<T>): Promise<VerifyResult<T>> {
  const delayMS = 5000
  return Promise.race([
    retry(f).then(right),
    setTimeout(delayMS, err<T>(`Failed to obtain a connection to Apalache after ${delayMS / 1000} seconds.`)),
  ])
}

// Try to establish a connection to the Apalache server
//
// A successful connection procudes an `Apalache` object.
async function connect(cmdExecutor: AsyncCmdExecutor): Promise<VerifyResult<Apalache>> {
  return retryWithTimeout(() => cmdExecutor.ping()).then(response => response.map(_ => apalache(cmdExecutor)))
}

/**
 * Verifies the configuration `config` by model checking it with the Apalache server
 *
 * @param config
 *   an apalache configuration. See https://github.com/informalsystems/apalache/blob/main/mod-infra/src/main/scala/at/forsyte/apalache/infra/passes/options.scala#L255
 *
 * @returns right(void) if verification succeeds, or left(err) explaining the failure
 */
export async function verify(config: any): Promise<VerifyResult<void>> {
  // Attempt to load proto definition:
  // - if APALACHE_DIST is set, from the Apalache distribution
  // - otherwise, via gRPC reflection
  const protoDefResult = process.env.APALACHE_DIST
    ? findApalacheDistribution().chain(dist => loadProtoDefViaDistribution(dist))
    : await loadProtoDefViaReflection()
  const connectionResult = await protoDefResult.chain(loadGrpcClient).asyncChain(connect)
  return connectionResult.asyncChain(conn => conn.check(config))
}
